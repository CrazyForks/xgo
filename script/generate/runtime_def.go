package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	args := os.Args[1:]
	var rootDir string
	if len(args) > 0 {
		rootDir = args[0]
	}
	err := generateAll(
		filepath.Join(rootDir, "runtime", "trap_runtime", "xgo_trap.go"),
		filepath.Join(rootDir, "cmd", "xgo", "patch", "runtime_def_gen.go"),
		filepath.Join(rootDir, "patch", "syntax", "syntax_gen.go"),
		filepath.Join(rootDir, "patch", "trap_gen.go"),
	)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func generateAll(file string, defFile string, syntaxFile string, trapFile string) error {
	content, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	code := string(content)
	astFile, fset, err := parseGoFile(file)
	if err != nil {
		return err
	}
	var decls []string
	var sigRegisterFunc string
	var sigTrap string
	for _, decl := range astFile.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if fn.Recv != nil {
			continue
		}
		fnName := fn.Name.Name
		if !strings.HasPrefix(fnName, "__xgo") {
			continue
		}
		funcType := fn.Type
		if fn.Name.Name == "__xgo_register_func" {
			sigRegisterFunc = getSignature(code, fset, funcType)
		} else if fn.Name.Name == "__xgo_trap" {
			sigTrap = getSignature(code, fset, funcType)
		}
		decls = append(decls, getSlice(code, fset, funcType.Pos(), funcType.End()))
	}
	if sigRegisterFunc == "" {
		return fmt.Errorf("__xgo_register_func not found")
	}
	if sigTrap == "" {
		return fmt.Errorf("__xgo_trap not found")
	}

	declCode := "// xgo\n" + strings.Join(decls, "\n")

	prelude := "// Code generated by script/generate; DO NOT EDIT.\n" + "\n"

	defGenCode := prelude + "package patch\n" + "\n" + "//go:generate go run ../../../script/generate ../../..\n" + "const RuntimeExtraDef = `\n" + declCode + "`"
	syntaxGenCode := prelude + "package syntax\n" + "\n" + "const sig_gen__xgo_register_func = `" + sigRegisterFunc + "`"
	trapGenCode := prelude + "package patch\n" + "\n" + "const sig_gen__xgo_trap = `" + sigTrap + "`"
	err = ioutil.WriteFile(defFile, []byte(defGenCode), 0755)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(syntaxFile, []byte(syntaxGenCode), 0755)
	if err != nil {
		return err
	}

	err = ioutil.WriteFile(trapFile, []byte(trapGenCode), 0755)
	if err != nil {
		return err
	}

	return nil
}

func getSlice(code string, fset *token.FileSet, start token.Pos, end token.Pos) string {
	i := fset.Position(start).Offset
	j := fset.Position(end).Offset
	return code[i:j]
}
func getSignature(code string, fset *token.FileSet, funcType *ast.FuncType) string {
	var end token.Pos

	if funcType.Results != nil {
		end = funcType.Results.End()
	} else {

		end = funcType.Params.End()
	}

	return "func" + getSlice(code, fset, funcType.Params.Pos(), end)
}

func parseGoFile(file string) (*ast.File, *token.FileSet, error) {
	fileName := file
	var contentReader io.Reader
	if file == "-" {
		fileName = "<stdin>"
		contentReader = os.Stdin
	} else {
		readFile, err := os.Open(file)
		if err != nil {
			return nil, nil, err
		}
		contentReader = readFile
	}

	content, err := ioutil.ReadAll(contentReader)
	if err != nil {
		return nil, nil, err
	}
	contentStr := string(content)
	lines := strings.Split(contentStr, "\n")
	var hasPackage bool
	for _, line := range lines {
		if strings.HasPrefix(strings.TrimSpace(line), "package ") {
			hasPackage = true
			break
		}
	}
	if !hasPackage {
		contentStr = "package main;" + contentStr
	}

	fset := token.NewFileSet()
	ast, err := parser.ParseFile(fset, fileName, contentStr, parser.ParseComments)
	if err != nil {
		return nil, nil, err
	}
	return ast, fset, nil
}
