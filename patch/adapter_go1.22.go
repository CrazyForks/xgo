//go:build go1.22 && !go1.23
// +build go1.22,!go1.23

package patch

import (
	"go/constant"

	"cmd/compile/internal/base"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
	"cmd/internal/src"
)

var intfSlice *types.Type

func forEachFunc(callback func(fn *ir.Func) bool) {
	for _, fn := range typecheck.Target.Funcs {
		if !callback(fn) {
			return
		}
	}
}

// go 1.20 does not require type
func NewNilExpr(pos src.XPos, t *types.Type) *ir.NilExpr {
	return ir.NewNilExpr(pos, t)
}

func AddFuncs(fn *ir.Func) {
	typecheck.Target.Funcs = append(typecheck.Target.Funcs, fn)
}

func NewFunc(fpos, npos src.XPos, sym *types.Sym, typ *types.Type) *ir.Func {
	return ir.NewFunc(fpos, npos, sym, typ)
}

func NewSignature(pkg *types.Pkg, recv *types.Field, tparams, params, results []*types.Field) *types.Type {
	return types.NewSignature(recv, params, results)
}

func NewBasicLit(pos src.XPos, t *types.Type, val constant.Value) ir.Node {
	return ir.NewBasicLit(pos, t, val)
}

// take address of all parameters
// go1.22
// func takeAddrs(fields []*types.Field) ir.Expr {
// 	if len(fields) == 0 {
// 		return NewNilExpr(base.AutogeneratedPos, intfSlice)
// 	}
// 	paramList := make([]ir.Node, len(fields))
// 	for i, f := range fields {
// 		paramList[i] = takeAddr(f)
// 	}
// 	return ir.NewCompLitExpr(base.AutogeneratedPos, ir.OCOMPLIT, intfSlice, paramList)
// }

func takeAddrs(fn *ir.Func, t []*types.Field) ir.Expr {
	if len(t) == 0 {
		return NewNilExpr(base.AutogeneratedPos, intfSlice)
	}
	paramList := make([]ir.Node, len(t))
	i := 0
	ForEachField(t, func(field *types.Field) bool {
		paramList[i] = takeAddr(fn, field)
		i++
		return true
	})
	return ir.NewCompLitExpr(base.AutogeneratedPos, ir.OCOMPLIT, intfSlice, paramList)
}

func getTypeNames(params []*types.Field) []ir.Node {
	paramNames := make([]ir.Node, 0, len(params))
	for _, p := range params {
		paramNames = append(paramNames, p.Nname.(*ir.Name))
	}
	return paramNames
}

func ForEachField(params []*types.Field, callback func(field *types.Field) bool) {
	n := len(params)
	for i := 0; i < n; i++ {
		if !callback(params[i]) {
			return
		}
	}
}

func getCallee(callNode *ir.CallExpr) ir.Node {
	return callNode.Fun
}
