package patch

import (
	"cmd/compile/internal/base"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
	"fmt"
	"go/constant"
	"io"
	"os"
	"strings"
)

func debugIR() {
	var dumpIRFile string
	dumpIR := os.Getenv("XGO_DEBUG_DUMP_IR")
	if dumpIR != "" {
		dumpIRFile = os.Getenv("XGO_DEBUG_DUMP_IR_FILE")
	} else {
		// fallback
		dumpIR = os.Getenv("COMPILER_DEBUG_IR_DUMP_FUNCS")
	}
	if dumpIR == "" || dumpIR == "false" {
		return
	}

	var outFile io.Writer

	if dumpIRFile != "" {
		file, err := os.OpenFile(dumpIRFile, os.O_WRONLY|os.O_CREATE, 0755)
		if err != nil {
			panic(fmt.Errorf("dump ir: %w", err))
		}
		defer file.Close()
		outFile = file
	}

	namePatterns := strings.Split(dumpIR, ",")
	forEachFunc(func(fn *ir.Func) bool {
		// fn.Sym().Name evaluates to plain func name, if with receiver, the receiver name
		// e.g.  A.B, (*A).C
		if !matchAnyPattern(types.LocalPkg.Path, types.LocalPkg.Name, fn.Sym().Name, namePatterns) {
			return true
		}
		if outFile == nil {
			ir.Dump("debug:", fn)
		} else {
			fmt.Fprintf(outFile, "%+v\n", fn)
		}
		return true
	})
}

func matchAnyPattern(pkgPath string, pkgName string, funcName string, patterns []string) bool {
	for _, pattern := range patterns {
		if matchPattern(pkgPath, pkgName, funcName, pattern) {
			return true
		}
	}
	return false
}

func matchPattern(pkgPath string, pkgName string, funcName string, pattern string) bool {
	dotIdx := strings.Index(pattern, ".")
	if dotIdx < 0 {
		return funcName == pattern
	}
	pkgPattern := pattern[:dotIdx]
	funcPattern := pattern[dotIdx+1:]

	return (pkgPattern == "*" || pkgPattern == pkgPath) && (funcPattern == "*" || funcPattern == funcName)
}

func debugPrint(s string) *ir.CallExpr {
	return ir.NewCallExpr(base.AutogeneratedPos, ir.OCALL, typecheck.LookupRuntime("printstring"), []ir.Node{
		NewBasicLit(base.AutogeneratedPos, types.Types[types.TSTRING], constant.MakeString(s)),
	})
}
